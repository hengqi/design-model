http://www.hollischuang.com/archives/1401
1. 概念
工厂方法（Factory Method Pattern）模式：又叫做虚拟构造器模式或者多态工厂模式，它属于类创建型模式。工厂方法模式实现了“工厂”概念的面向对象的设计模式。
就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。

工厂方法模式的实质是：定义一个创建对象的接口，但让实现这个接口的类来决定实例化那个类。工厂方法让类的实例化推迟到子类中进行。

2. 用途：工厂方法模式和简单工厂模式虽然都是通过工厂来创建对象，但他们之间最大的不同是--工厂方法模式在设计上完全符合“开闭原则”。
在一下情况下可以使用工厂方法模式：
    2.1 一个类不知道他所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。
    2.2 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，
    子类对象将覆盖父类对象，从而使得系统更容易扩展。
    2.3 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无需关心是哪一个工厂子类创建产品子类，需要时再动态指定，可敬具体工厂类的类名字存储在配置文件或者数据库中。

3. 角色
    3.1 抽象工厂类角色：在java中往往由一个抽象类或接口实现。（OperationFactory）
    3.2 具体工厂角色：实现抽象工厂的创建方法，然后创建具体的产品，通常是一个子类来实现。
    3.2 抽象产品角色：它一般是具体产品角色继承的父类或者实现的接口。在java中由接口或者抽象类来实现。（Operation）
    3.3 具体产品角色：工厂类所创建的对象就是词角色的实例。在java中由一个具体类实现。（OperationAdd\OperationSub等）

4. 工厂方法模式的利与弊：
    4.1 为什么要使用工厂来创建对象？
        --封装对象的创建过程
        在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。
        基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。
        工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。
    4.2 为什么每种对象要单独有一个工厂？
        --符合『开放-封闭原则』
        主要目的是为了解耦。在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。
        这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。

    4.3 以上就是工厂方法模式的优点。但是，工厂模式也有一些不尽如人意的地方：
    在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。
    由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。

5. 工厂方法与静态工厂方法（简单工厂）的区别
    工厂模式克服了简单工厂模式违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。
    他们都是集中封装了对象的创建，使得要更换对象时，不需要做大的改动就可实现，降低了客户端与产品对象的耦合。

6. 总结
    工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。

    在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，
    这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。

    工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，
    导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。